#!/bin/bash
usage()
{
cat << EOF
usage: $0 [OPTIONS] [--] COMMAND

Takes the output of a command and reports it to sensu.

OPTIONS:
   -h      Show help
   -n      Specify the name of the check. Defaults to the name of the command you run with args.
   -l      Send the output of the command to logger as well as Sensu with a provided tag.
   -d      Dry run, send the output what would be sent to Sensu to stderr.
   -H      String of an array of handlers. Defaults to empty. (use default handlers)
   -j      Specify custom json to cover a need that I can't think of. (see examples)
   -c      Count of the numer of lines to output ot sensu. Default: 3

Examples:

    $0 /bin/false
    (reports the output to sensu sliently, with a name of /bin/false)

    $0 -l dailycron -n "Daily Apt Get Cron" /usr/bin/apt-get update
    (Get a sensu alert when your daily apt-get cron job fails, and get logs to syslog)

    $0 -H "['email', 'pagerduty']" -- /usr/bin/my_critical_command
    (Be explicity about handlers to use. Optional -- to separate the command)

    $0 -n "Special Check" -j '"playbook": "http://wiki/special_check", "metric: false",' -- /usr/bin/special_check
    (For when you need extra json in the output. NOTE: INCLUDE A TRAILING COMMA)
    
EOF
}

while getopts "hn:l:dH:j:vc:" opt; do
  case $opt in
    h)
      usage
      exit 1
      ;;
    n)
      CHECK_NAME="$OPTARG"
      ;;
    l)
      # We can get by with just prepending with a pipe
      # and using this in our command directly
      LOG_ARG="| -l $OPTARG"
      ;;
    d)
      DRYRUN=true
      ;;
    H)
      HANDLERS="\n'handlers': ${OPTARG},"
      ;;
    j)
      EXTRA_JSON="\n${OPTARG}"
      ;;
    c)
      LINE_COUNT="$OPTARG"
      ;;
    \?)
      usage
      exit 1
      ;;
  esac
done

# Shift up to the command itself
shift $((OPTIND-1))

# Fail early if there isn't even a command specified
if [[ -z "$*" ]]; then
  echo "Error: No command specified"
  usage
  exit 1
fi

# Dryrun mode should spit to stderr. 
# Normal mode goes to local sensu agent
if [[ $DRYRUN == true ]]; then
  OUTPUT_DESTINATION='/dev/fd/2'
else
  OUTPUT_DESTINATION='/dev/tcp/localhost/3030'
fi

# Default line count
[[ -z "$LINE_COUNT" ]] && LINE_COUNT=3 

# When an explicity name is not provided, we default to the command
# that was asked to be run. 
if [[ -z "$CHECK_NAME" ]]; then
  CHECK_NAME=$*
fi

# Actually execute the command and suck in the result
set -o pipefail
CHECK_RESULT=$( $* 2>&1 $LOG_ARG | tail -n $LINE_COUNT )
RET_CODE=$?

# Get the check result and send it to the right place
echo -e "{
'name': '$CHECK_NAME',
'output': '$CHECK_RESULT', ${EXTRA_JSON}${HANDLERS}
'status': '$RET_CODE'
}" >$OUTPUT_DESTINATION
OUTPUT_RETURN=$?

if [[ $OUTPUT_RETURN == 0 ]]; then
  # Explicitly return the return code that actually occured if we are in
  # passthrough mode. Otherwise, if we are a check or cron job, hide the
  # return code, as it is reported to Sensu.
  if [[ "$PASS_THROUGH" == true ]]; then
    exit $RET_CODE
  else
    exit 0
  fi
else
  # If the output failed, then possibly the sensu agent is not running
  # We choose to exit 1 regardless.
  echo "Error: Could not send to Sensu!" >&2
  echo "$OUTPUT" >&2
  echo "Return code: $RET_CODE" >&2
  exit 1
fi


